from subprocess import run, PIPE
import os
import time
from io import StringIO

from core.core import Core
from core.workspace import Workspace
from graph_models.disassembly_analysis import Disassembly, Instruction
from graph_models.grap_analysis import GrapAnalysis, PatternOccurrence
from modules.base_module import BaseModule
from containers.grap.graprunner import GRAPRunner
from plugins.instruction_matcher import InstructionMatcher
from plugins.dotIO import DotIO
from plugins.csvIO import CsvIO


class Grap(BaseModule):
    inputTemplates = [Disassembly, type(None)]
    outputTemplate = GrapAnalysis

    @staticmethod
    def apply(target, grap_analysis):
        """Construct annotations between a target and a Grap analysis
        param target: target analysis
        param grap_analysis: grap analysis
        """
        print("\n--- Grap - apply ---\n")
        print("Constructing annotations between {} and Grap analysis..".format(type(target).__name__))

        # hardcoded per-target type annotation construction
        # if multiple targets share the same annotation logic
        # e.g 'annotate instructions in the target analysis which were matched by Grap'
        # we can create a more flexible way of doing this:
        # first, find the matching instructions between the grap analysis and a generic analysis
        # by taking a string as additional parameter describing how Instructions can be reached from the target
        # analysis root node (see the path value in the dictionaries below)
        # finding matching strings via the InsMatcher plugin.
        # Constructing annotations can be done oblivious to target type then.
        # ---
        # This is also were the idea of self-descriptive analyses comes in:
        # if implemented we would not have to specify this path as an extra param,
        # the analysis model itself describes how Instructions can be reached.
        # This can be done by iterating over the 'RelatedTo' properties until an Instruction node is reached
        if type(target) == Disassembly:
            source_analysis = {
                'analysis': grap_analysis,
                'path': "(target_instruction:Instruction)<-[]-(:PatternOccurrence)<-[]-(source_analysis:Analysis)"
            }
            target_analysis = {
                'analysis': target,
                'path': "(target_instruction:Instruction)<-[]-(:BasicBlock)<-[]-(source_analysis:Analysis)"
            }
            ins_matcher = InstructionMatcher(source_analysis, target_analysis)
            matched_ins = ins_matcher.run()

            annotations = []
            for match in matched_ins:
                for target_ins in match.get_matches():
                    annotation = match.source.annotates(target_ins, type='Grap')
                    annotations.append(annotation)
        return annotations

    def __init__(self, input_analysis=None, grap_file=None):
        """Initialize a Grap module
        param(optional) input_analysis: disassembly analysis to operate on
        param(optional) grap_file: path to pattern file
        """
        super(Grap, self).__init__(input_analysis)

        self.disassembly = input_analysis
        self.grap_file = grap_file or Core().get_subdirectory('modules', 'grap', 'aes.grapp')
        # Output file for the GRAP builtin disassembler
        cfg_filename = self.binary_name + '_' + (self.disassembly.module if self.disassembly else "GrapCapstone")
        self.cfg_file = os.path.join(self.tmp_path, cfg_filename + '.grapcfg')

    def import_disassembly(self):
        """Import the disassembly generated by standalone Grap"""
        if not os.path.exists(self.cfg_file):
            print('grapcfg not found @', self.cfg_file)
            return

        disassembly = DotIO.cfg_from_dot(self.binary_path, self.cfg_file)
        disassembly.module = 'Grap'
        disassembly = CsvIO.csv_insert_disassembly(self.binary_path, disassembly)
        disassembly.inheritors.add(self.analysis)

        Workspace.current.graph.push(disassembly)
        return disassembly

    def run(self):
        print("\n--- Grap ---\n")

        if self.disassembly:
            # generate grapcfg file for this disassembly, if not already present
            if not os.path.exists(self.cfg_file):
                print("Generating grap compatible dotfile from disassembly..")
                DotIO.cfg_to_dot(self.disassembly, self.cfg_file)
            # cmd = "grap -nd {} {}".format(self.grap_file, self.cfg_file)
            cmd = "-nd {PATTERN} {CFG}"
        else:
            # cmd = "grap {} --cfg-output {} {}".format(self.grap_file, self.cfg_file, self.binary_path)
            cmd = "{PATTERN} --cfg-output {CFG} {BINARY}"

        runner = GRAPRunner(Core().docker_client, cmd, self.grap_file, self.cfg_file, self.binary_path)
        output = str(runner.run(), "utf-8")
        print(output)
        # print("Running Grap, cmd:")
        # print(cmd)
        # completed = run(cmd.split(), stdout=PIPE, stderr=PIPE)
        # output = str(completed.stdout, 'utf-8')

        print("\nImporting pattern matches..")
        results = self.__import_results(output)

        print("\nConstructing analysis subgraph")
        self.__map_results(results)
        return self.analysis

    def __import_results(self, grap_output):
        """Grap output format:
        ./7za.grapcfg - 228703 instructions
        2 matches: aes_round_v2 (2)

        aes_round_v2 - match 1
        a_shl1: 0xb8a3, shl edx, 0x10
        b_int0: 0xb8a6, mov eax, ecx
        b_int1: 0xb8a8, shr eax, 0x18
        b_int2: 0xb8ab, movzx ebx, byte ptr [edi + eax - 0x56ed0]
        c_shl2: 0xb8b3, shl ebx, 0x18

        aes_round_v2 - match 2
        a_shl1: 0xb924, shl edx, 0x10
        b_int0: 0xb927, movzx eax, cl
        b_int1: 0xb92a, movzx ebx, byte ptr [edi + eax - 0x56ed0]
        b_int2: 0xb932, mov eax, ebx
        c_shl2: 0xb934, shl eax, 0x18
        """
        import_start = time.perf_counter()

        results = {}

        with StringIO(grap_output) as f:
            # skip header
            f.readline()
            f.readline()
            pattern = None
            for line in f:
                if line.find("match") > -1:
                    pattern = line.rpartition(" - ")[0]
                    if pattern not in results:
                        results[pattern] = [[]]
                    else:
                        results[pattern].append([])
                elif pattern:
                    match = line.partition(': ')
                    node = match[0]
                    match = match[2].rstrip().split(', ')
                    if len(match) < 2:
                        pattern = None
                        continue
                    address = match[0]
                    ins = match[1:]
                    mnem_op1 = ins[0].split(' ')
                    mnem = mnem_op1[0]
                    if len(mnem_op1) > 1:
                        operands = [mnem_op1[1]]
                    if len(ins) > 1:
                        operands += ins[1:]
                    results[pattern][-1].append((address, mnem, operands, node))

        import_end = time.perf_counter()
        print(f'Importing results took {import_end-import_start} second(s).')

        return results

    def __map_results(self, results):
        for pattern in results:
            print("{} : {} matches".format(pattern, len(results[pattern])))
            for match in results[pattern]:
                pattern_node = PatternOccurrence()
                pattern_node.pattern = pattern
                for ins in match:
                    ins_node = Instruction()
                    ins_node.image_name = os.path.basename(self.binary_path)
                    ins_node.image_offset = int(ins[0], base=16)
                    ins_node.mnem = ins[1]
                    ins_node.operands = ins[2]
                    pattern_node.nodes.add(ins_node, node_id=ins[3])
                self.analysis.patterns.add(pattern_node)
